<!DOCTYPE html>
<html>
<script lang="javascript" src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script> <!--Sheets JS-->
<script src="https://d3js.org/d3.v7.min.js"></script>
<head>
<title>Page Title</title>
</head>
<body>
<p>Step 1. Use Batch Rename Utility to put "serXXXX" where XXXX is the sensor serial number at the front of the file name for each LOG file</p>
<p>Step 2. Place all LOG files in a single directory with the logdecoder.exe. In this example, this was "C:\idaq\space\"</p>
<p>Step 3. Make a new Batch file in this directory with the only line inside: "for %%f in (.\ser*) DO c:\idaq\space\logdecoder.exe %%f"</p>
<p>Step 4. Execute the Batch file. This should open a terminal and show the logdecoder.exe at work</p>
<p>Step 5. Use this utility by selecting all your csv's at the same time with the Open command below</p>
<p>Step 6. Your browswer will prompt you to save the output file. It's a csv too and I hope it fits on your computer!</p>
<p>CSV File(s): <input multiple type="file" name="fileinput" id="fileinputid" onchange="openBatchCSV()" accept=".csv"/></p>
<p id="rstatus">status:</p>
</body>
<script>

    var curr_file;
    var num_files;
    var big_data = [];
    var linecount;

    function openBatchCSV(){
        linecount = 0;
		document.getElementById("rstatus").innerHTML += "opencsv() start,";
        var str = "20240123-204239";
        document.getElementById("rstatus").innerHTML += "*"+(str.slice(0,8))+"*";
        document.getElementById("rstatus").innerHTML += "*"+(str.slice(9))+"*";
		num_files = event.target.files.length;
		//curr_file = 0;
        //for(var i = 0; i < num_files; i++){ //commented out means this is recursive
            openOneCSV(0,event); 
        //}
		document.getElementById("rstatus").innerHTML += "opencsv() done,";
    }

    function openOneCSV(index, event){
		document.getElementById("rstatus").innerHTML += "openOnecsv() start,";
        var f = event.target.files[index];
        const reader = new FileReader();
        reader.onload = function(e){
            document.getElementById("rstatus").innerHTML += "fileReaderStarting,";
            const text = e.target.result;
            const data = d3.csvParse(text);
            var fname = f.name;
            process_json(data, fname);
            //if(curr_file == num_files - 1){
            if(index == num_files - 1){
            //draw the stuff now:
                document.getElementById("rstatus").innerHTML += "Last file completed. pulled "+big_data.length+" lines from "+linecount+" total lines";
                generateTable(big_data,30000);
            }
            else{
                openOneCSV(index+1, event);
            }
            curr_file++;
        };
        reader.readAsText(f);
    }

    function process_json(data, filename){
        var sel_data = data.map(
            ({
                time, xgyro, ygyro, zgyro, xaccl, yaccl, zaccl, GPSFixMode, GPSDateTime, GPSLongitude, GPSLatitude, GPSGroundSpeed
            }) =>
            {
            return{
                time, xgyro, ygyro, zgyro, xaccl, yaccl, zaccl, GPSFixMode, GPSDateTime, GPSLongitude, GPSLatitude, GPSGroundSpeed
                }
            }
        );
        for(var i = 0; i < sel_data.length; i++){
            //add metadata
            sel_data[i].filename = filename;
			//make sure all text is entered as float/int values
			sel_data[i].time = parseInt(sel_data[i].time);
			sel_data[i].xgyro = parseFloat(sel_data[i].xgyro);
            sel_data[i].ygyro = parseFloat(sel_data[i].ygyro);
            sel_data[i].zgyro = parseFloat(sel_data[i].zgyro);
            sel_data[i].xaccl = parseFloat(sel_data[i].xaccl);
            sel_data[i].yaccl = parseFloat(sel_data[i].yaccl);
            sel_data[i].zaccl = parseFloat(sel_data[i].zaccl);
            sel_data[i].maccl = Math.sqrt(sel_data[i].xaccl*sel_data[i].xaccl+sel_data[i].yaccl*sel_data[i].yaccl+sel_data[i].zaccl*sel_data[i].zaccl);
            sel_data[i].active = 0;
            sel_data[i].GPSFixMode = parseInt(sel_data[i].GPSFixMode);
            //GPSDateTime will remain as text excample 20240123-204239
            sel_data[i].GPSDate = parseInt(sel_data[i].GPSDateTime.slice(0,8));
            sel_data[i].GPSTime = parseInt(sel_data[i].GPSDateTime.slice(9));
            sel_data[i].GPSLongitude = parseFloat(sel_data[i].GPSLongitude);
            sel_data[i].GPSLatitude = parseFloat(sel_data[i].GPSLatitude);
            sel_data[i].GPSGroundSpeed = parseFloat(sel_data[i].GPSGroundSpeed);
        }
        //threshold finder
        const lookforward = 1000;
        const lookbackward = 100;
        var syson = 0;
        var decay;
        const threshold = 2;
        for(var i = 0; i < sel_data.length; i++){
            if(sel_data[i].maccl > threshold){
                sel_data[i].active = 1;
                decay = lookforward; //whenever other threshold, reset decay counter to the top value.
                if(syson == 0){ 
                    //CONDITION: if accel is over threshold and system was idle, go active and also look backward and set active
                    for(var back = i - lookbackward; back < i; back++){
                        if(back > 0){
                            sel_data[i].active = 1;
                        }
                    }
                    syson = 1; //now set to syson to avoid any more lookbacks.
                }
            }
            else{
                if(syson == 1){
                    //CONDITION: if accel is under threshold and system was active, do the decay and check if decay hits zero
                    decay--;
                    sel_data[i].active = 1;
                    if(decay == 0){
                        syson = 0;
                    }
                }
                //else CONDITION: if accel is under threshold and system is off, keep data inactive.
            }
        }
        //store it
        var filtered = [];
        for(var i = 0; i < sel_data.length; i++){
            linecount++;
            if(sel_data[i].active == 1){
                var activeitem = {};
                activeitem = sel_data[i];
                filtered.push(activeitem);
                big_data.push(activeitem);
            }
        }
        generateTable(sel_data, 2);
        //big_data.push(filtered);
    }

    function generateTable(data, maxlines) {
        // creates a <table> element and a <tbody> element
        const tbl = document.createElement("table");
        const tblBody = document.createElement("tbody");
        if(data.length < 1){
            console.log("array of length 0");
        }
        // creating all cells
        for (let i = 0;  i < data.length && i < maxlines; i++) {
            // creates a table row
            const row = document.createElement("tr");

            for (let key in data[i]) {
                // Create a <td> element and a text node, make the text
                // node the contents of the <td>, and put the <td> at
                // the end of the table row
                const cell = document.createElement("td");
                const cellText = document.createTextNode(data[i][key].toString());
                cell.appendChild(cellText);
                row.appendChild(cell);
            }
            // add the row to the end of the table body
            tblBody.appendChild(row);
        }
        // put the <tbody> in the <table>
        tbl.appendChild(tblBody);
        // appends <table> into <body>
        document.body.appendChild(tbl);
        // sets the border attribute of tbl to '2'
        tbl.setAttribute("border", "2");
    }

</script>
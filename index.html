<!DOCTYPE html>
<html>
<script lang="javascript" src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script> <!--Sheets JS-->
<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Color Scale -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<head>
<title>Page Title</title>
</head>
<body onload="onLoad()">
<b>Step 1.</b> Use Batch Rename Utility to put "serXXXX" where XXXX is the sensor serial number at the front of the file name for each LOG file<br>
<b>Step 2.</b> Place all LOG files in a single directory with the logdecoder.exe. In this example, this was "c:\space\"<br>
<b>Step 3.</b> Make a new Batch file (that's text with extension .bat) in the c:\space\ directory with the only line inside: "for %%f in (.\ser*) DO c:\space\logdecoder.exe %%f"<br>
<b>Step 4.</b> Execute the Batch file. This should open a terminal and show the logdecoder.exe at work<br>
<b>Step 5.</b> Modify the following parameters as you see fit. The G-threshold is the magnitude of the acceleration vector, and framesize
    is how many samples to capture on either side of an event that is over that G-threshold.<br>
<b>Step 6.</b> Use the "Open" button to select all .csv files of interest and trim down according to criteria (threshold and look back/forward).<br>
<label for="gthreshold">G threshold:</label>
<input type="number" id="idgthreshold" name="gthreshold" value="3" step="0.1" style="width: 50px;">
<label for="framesize">Look back/look forward:</label>
<input type="number" id="idframesize" name="framesize" value="1000" step="1" style="width: 75px;">
<input type="checkbox" id="idgimme" name="gimme" onchange="checkignorethreshold()"><label for="gimme">Ignore the G-threshold, I want everything.</label><br>
<p>CSV File(s): <input multiple type="file" name="fileinput" id="fileinputid" onchange="fatOpen()" accept=".csv"/></p>
<b>Step 7 (optional)</b>: Save the filtered CSV as an XLSX. <button onclick="downloadXLSX()" id="id_download_xlsx" disabled>Download XLSX</button><br>
This will likely fail if there are more than 1 million rows of data. You can however skip this step and go to drawing, but each time the page
refreshes you'll need to reload the CSV's again.<br>
<b>Shortcut.</b> If you finished Step 7, choose the file and we can start from there.<br>
<p>XLSX File: <input type="file" name="xlsxinput" id="xlsxinputid" onchange="openOneXLSX()" accept=".xlsx"/></p>
<hr>
<p>Match Event File: <input type="file" id="knowneventinput" onchange="openOneEventXLSX()" accept=".xlsx"/></p>
<hr>
<p>CSV Info:<a id="csvstatus"></a></p>
<p>Log Info:<a id="datastatus"></a></p>
<hr>
Filename:<select name="whichfile" id="idselectfile" onchange="newselectfile()"></select><a id="filestatus"></a>
Event:<select name="whichevent" id="idselectevent" onchange="newselectevent()"></select><a id="eventstatus"></a>
<input type="button" id="idbuttonsample" disabled value="set to bounds" onclick="sendtobounds()"><br>
Draw options: 
 <input type="checkbox" id="idmaccl" checked onchange="attemptdraw()">maccl
 <input type="checkbox" id="idxaccl" checked onchange="attemptdraw()">xaccl
 <input type="checkbox" id="idyaccl" checked onchange="attemptdraw()">yaccl 
 <input type="checkbox" id="idzaccl" checked onchange="attemptdraw()">zaccl
 <input type="checkbox" id="idauto" checked>Update on change?
 <input type="button" id="id_draw_button" disabled value="Draw" onclick="drawSelected()"><br>
X-min:<input type="number" id="idxmin" name="namexmin" value="0" step="1" style="width: 100px;" onchange="attemptdraw()">
X-max:<input type="number" id="idxmax" name="namexmin" value="1000" step="1" style="width: 100px;" onchange="attemptdraw()">
y-Min (G's):<input type="number" id="idymin" name="nameymin" value="-25" step="1" style="width: 50px;" onchange="attemptdraw()">
y-Max (G's):<input type="number" id="idymax" name="nameymax" value="25" step="1" style="width: 50px;" onchange="attemptdraw()">
Dot Radius:<input type="number" id="idradius" name="nameymax" value="2" step="1" style="width: 50px;" onchange="attemptdraw()">
<input type="button" id="id_draw_next" disabled value="Go to Next Event" onclick="AutoPlotNext()">
<!--<progress id="readyizeprogress" value="0" max="100"></progress>-->
<div id="theplot"></div>
</body>
<script>
    var progressBar;
    const thelabels = ["maccl","xaccl","yaccl","zaccl"];
    const thecolors = d3.schemeSet1;
    var num_files;
    var big_data = []; //json format, single x value (milliseconds) available to use. 2-Dimensional
    var linecount = 0;
    var framesize;
    var gthreshold;
    var organized_data = []; //organized by file-index, then event-index, then 0-index on the sample it is.
    var ignorethreshold = false; //ignore threshold and grab everything from the CSV
    var ignoreexcel = false; //don't bother making an xlsx.
    var filenames = [];
    var fileeventlist = [];
    var excelfilename = "";
    var whichfileselected = 0;
    var known_event_data = [];

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  SIMPLE HTML/JAVSCRIPT INTERFACE
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function attemptdraw(){
        if(document.getElementById("id_draw_button").disabled == false && 
           document.getElementById("idauto").checked == true)
           {
            drawSelected();
           }
    }

    function onLoad(){}

    function sendtobounds(){
        var whicheventselected = parseInt(document.getElementById("idselectevent").value);
        var val = organized_data[whichfileselected][whicheventselected].length;
        document.getElementById("idxmax").value = val;
        document.getElementById("idxmin").value = 0;
        drawSelected();
    }

    function newselectevent(){
        var whicheventselected = parseInt(document.getElementById("idselectevent").value);
        document.getElementById("eventstatus").innerHTML = "contains "+organized_data[whichfileselected][whicheventselected].length+" samples.";
    }

    function newselectfile(){
        var whichfile = document.getElementById("idselectfile").value;
        var eventsize = 0;
        for(var f = 0; f < filenames.length; f++){
            if(whichfile == filenames[f]){
                eventsize = fileeventlist[f];
                whichfileselected = f;
            }
        }
        document.getElementById("idselectevent").innerHTML = ""; //boo-yeah
        for(var q = 0; q <= eventsize; q++){
            var eoption = document.createElement('option');
            eoption.text = eoption.value = q;
            document.getElementById("idselectevent").add(eoption);
        }
        document.getElementById("filestatus").innerHTML = "contains "+fileeventlist[whichfileselected]+" events.";
        document.getElementById("eventstatus").innerHTML = "contains "+organized_data[whichfileselected][0].length+" samples.";
        document.getElementById("idbuttonsample").disabled = false;
        document.getElementById("idxmax").value = organized_data[whichfileselected][0].length;
    }

    function checkignoreexcel(){ ignoreexcel = !ignoreexcel;    }
    function checkignorethreshold(){ ignorethreshold = !ignorethreshold;  }
    
    function generateTable(data, maxlines) {
        const tbl = document.createElement("table");
        const tblBody = document.createElement("tbody");
        if(data.length < 1){
            console.log("array of length 0");
        }
        for (let i = 0;  i < data.length && i < maxlines; i++) {
            const row = document.createElement("tr");
            for (let key in data[i]) {
                const cell = document.createElement("td");
                const cellText = document.createTextNode(data[i][key].toString());
                cell.appendChild(cellText);
                row.appendChild(cell);
            }
            tblBody.appendChild(row);          
        }
        tbl.appendChild(tblBody);       
        document.body.appendChild(tbl);     
        tbl.setAttribute("border", "2");       
    }

    function AutoPlotNext(){
        if(!alreadyplotted){
            drawSelected();
            return;
        }
        //increment the event selection
        //maybe increment the file
        var whicheventselected = parseInt(document.getElementById("idselectevent").value);
        document.getElementById("idselectevent").options[whicheventselected].selected = false;
        whicheventselected++;
        if(whicheventselected > fileeventlist[whichfileselected]){
            document.getElementById("idselectfile").options[whichfileselected].selected = false;
            whichfileselected++;
            whicheventselected = 0;
            if(whichfileselected == filenames.length){
                whichfileselected = 0;
            }
            document.getElementById("idselectfile").options[whichfileselected].selected = true;
            newselectfile();
        }
        //console.log(whichfileselected, whicheventselected, filenames[whichfileselected], fileeventlist[whichfileselected]);
        document.getElementById("idselectevent").options[whicheventselected].selected = true;
        //set to bounds
        document.getElementById("idxmin").value = 0;
        document.getElementById("idxmax").value = organized_data[whichfileselected][whicheventselected].length;
        //draw
        drawSelected();
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // FILE I/O FUNCTIONS
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    const useheader = ['time', 'xaccl', 'yaccl', 'zaccl', 'GPSDateTime'];
    var   usecolumns = [0,0,0,0,0];
    var   useNumber = [true, true, true, true, false];
    var   useInteger = [true, false, false, false, false];

    function fatOpen(){
        gthreshold = document.getElementById("idgthreshold").value;
        framesize = document.getElementById("idframesize").value;
        num_files = event.target.files.length;
        openOneCSVinSlices(0, event);//104857600
    }

    function openOneCSVinSlices(index, event){
        const chunksize = 104857600; //104857600; 100MB. Chunk size must be a large enough number. too small and you won't even read a single line at a time!
        var f = event.target.files[index];
        var raw_data = [];
        const reader = new FileReader();
        getOneSlice(0);
        function getOneSlice(startbyte){
            var next_slice = startbyte + chunksize + 1;
            var blob = f.slice(startbyte, next_slice);
            reader.onload = function(e){
                var size_done = startbyte + chunksize;
                var text = e.target.result;
                var byline = text.split('\n'); //separate text by line.
                //console.log(byline[0]);
                //loop through each line.
                var notlastslice = 1; //the ending is MINUS ONE because last line will be left overs intentionally
                if(next_slice > f.size){
                    notlastslice = 0; //changes for-loop behavior to read the last line too. otherwise it goes into the leftovers
                }
                for(var i = 0; i < byline.length - notlastslice; i++){ 
                    var dataline = {};
                    var thisline = byline[i].split(',');
                    //step 1: if we're on line 0 of the file, this is the header. read it in and figure out where our columns are in the file.
                    if(startbyte == 0 && i == 0){
                        for(var q = 0; q < thisline.length; q++){
                            for(var r = 0; r < usecolumns.length; r++){
                                if(thisline[q] === useheader[r]){
                                    usecolumns[r] = q;
                                }
                            }
                        }
                        //console.log(usecolumns);
                    }
                    else{
                        //read it in as data
                        dataline['time'] = thisline[usecolumns[0]];
                        dataline['xaccl'] = thisline[usecolumns[1]];
                        dataline['yaccl'] = thisline[usecolumns[2]];
                        dataline['zaccl'] = thisline[usecolumns[3]];
                        dataline['GPSDateTime'] = thisline[usecolumns[4]];
                    }
                    raw_data.push(dataline);
                }
                if(next_slice < f.size){
                    //figure out the left overs issue
                    var leftovers = byline[byline.length-1].length;
                    getOneSlice(next_slice-leftovers);
                }
                else{
                    if(raw_data.length < 1){
                        alert(f.name +" had 0 lines or was too large!");
                    }
                    else{
                        process_json(raw_data, f.name);
                    }
                    document.getElementById("csvstatus").innerHTML += f.name+"<br />";
                    if(index == num_files - 1){
                    //then you're done loading the csv files
                        document.getElementById("csvstatus").innerHTML = "I have "+big_data.length+" lines from "+linecount+" total lines";
                        if(big_data.length > 0){
                            document.getElementById("id_download_xlsx").disabled = false;
                        }
                        readyize();
                    }
                    else{
                        openOneCSVinSlices(index+1, event);
                    }
                }
            };
            reader.readAsText(blob);
        }
    }
    /*
    function openBatchCSV(){
        gthreshold = document.getElementById("idgthreshold").value;
        framesize = document.getElementById("idframesize").value;
		num_files = event.target.files.length;
        openOneCSV(0,event); 
    }
    function openOneCSV(index, event){
        var f = event.target.files[index];
        const reader = new FileReader();
        reader.onload = function(e){
            const text = e.target.result;
            const data = d3.csvParse(text);
            if(data.length < 1){
                alert(f.name +" had 0 lines or was too large!");
            }
            var fname = f.name;
            document.getElementById("csvstatus").innerHTML += fname+"<br />";
            process_json(data, fname);
            if(index == num_files - 1){
            //then you're done loading the csv files
                document.getElementById("csvstatus").innerHTML = "Last file completed. I have "+big_data.length+" lines from "+linecount+" total lines";
                if(big_data.length > 0){
                    document.getElementById("id_download_xlsx").disabled = false;
                }
                readyize();
            }
            else{
                openOneCSV(index+1, event);
            }
        };
        reader.readAsText(f);
    }
    */
    function openOneXLSX(){
        var f = event.target.files[0];
        const reader = new FileReader();
        excelfilename = f.name;
        reader.onload = function(e){
            var binaryString = e.target.result;
            var inputWorkbook = XLSX.read(binaryString, {type: 'binary'});
            var firstSheetname = inputWorkbook.SheetNames[0];
            var firstWorksheet = inputWorkbook.Sheets[firstSheetname];
            big_data = XLSX.utils.sheet_to_json(firstWorksheet, {defval:"0"});
            readyize();
            console.log(organized_data);
        }
        reader.readAsBinaryString(f);
    }

    function downloadXLSX() {
        const worksheet = XLSX.utils.json_to_sheet(big_data);		
	    const workbook  = XLSX.utils.book_new();
	    XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
	    XLSX.writeFile(workbook, "output.xlsx", {compression:true});
    }

    function downloadMatchesXLSX() {
        const worksheet = XLSX.utils.json_to_sheet(known_event_data);		
	    const workbook  = XLSX.utils.book_new();
	    XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
	    XLSX.writeFile(workbook, "output.xlsx", {compression:true});
    }

    function openOneEventXLSX(){
        var f = event.target.files[0];
        const reader = new FileReader();
        excelfilename = f.name;
        reader.onload = function(e){
            var binaryString = e.target.result;
            var inputWorkbook = XLSX.read(binaryString, {type: 'binary'});
            var firstSheetname = inputWorkbook.SheetNames[0];
            var firstWorksheet = inputWorkbook.Sheets[firstSheetname];
            known_event_data = XLSX.utils.sheet_to_json(firstWorksheet, {defval:"0"});
            matchevents();
        }
        reader.readAsBinaryString(f);
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // PROCESS JSON / PARSING
    // Input: data is a d3.parseCSV(filename), and "filename" is string of the filename
    // Output: no return.
    // Action: strips off columns to leave time, x y z gyro, x y z accl, GPSFixMode, GPSDateTime, and ADDS filename, line, decay, eventcounter
    // and stores "data" into global "big_data" as a push() command.
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function parseFloatNaN(passed){
        var answer = parseFloat(passed);
        if(isNaN(answer)) return 0;
        return answer;
    }
    function parseIntNaN(passed){
        var answer = parseInt(passed);
        if(isNaN(answer)) return 0;
        return answer;
    }

    function process_json(data, filename){
        var step = (data.length)/10;
        var nextstep = step;
        var sel_data = data.map( //strips off the other columns that are not mentioned here, like GPS Lat/Long
            ({
                time, 
                xgyro, ygyro, zgyro, 
                xaccl, yaccl, zaccl, //GPSFixMode, 
                GPSDateTime
            }) =>
            {
            return{
                time, 
                xgyro, ygyro, zgyro, 
                xaccl, yaccl, zaccl, //GPSFixMode, 
                GPSDateTime
                }
            }
         );
        for(var i = 0; i < sel_data.length; i++){
            //internal functions on parsing floats and ints. If NaN, assume 0. Typical for empty cells.
            
            //add metadata of filename, and a linecounter (unique to entire dataset in use)
            sel_data[i].filename = filename;
            //sel_data[i].line = linecount;
            linecount++;
            //sel_data[i].decay = 0;
            sel_data[i].eventcounter = 0;
			//make sure all text is entered as float/int values
			sel_data[i].time = parseInt(sel_data[i].time);
			sel_data[i].xgyro = parseFloatNaN(sel_data[i].xgyro);
            sel_data[i].ygyro = parseFloatNaN(sel_data[i].ygyro);
            sel_data[i].zgyro = parseFloatNaN(sel_data[i].zgyro);
            sel_data[i].xaccl = parseFloatNaN(sel_data[i].xaccl);
            sel_data[i].yaccl = parseFloatNaN(sel_data[i].yaccl);
            sel_data[i].zaccl = parseFloatNaN(sel_data[i].zaccl);
            sel_data[i].maccl = Math.sqrt(sel_data[i].xaccl*sel_data[i].xaccl+
                                          sel_data[i].yaccl*sel_data[i].yaccl+
                                          sel_data[i].zaccl*sel_data[i].zaccl);
            sel_data[i].active = 0;
            //sel_data[i].GPSFixMode = parseInt(sel_data[i].GPSFixMode);
            //GPSDateTime will remain as text example 20240123-204239
            //sel_data[i].GPSDate = parseIntNan(sel_data[i].GPSDateTime.slice(0,8));
            //sel_data[i].GPSTime = parseIntNan(sel_data[i].GPSDateTime.slice(9));
        }
        //mark events by threshold being exceeded
        const lookforward = framesize;
        var syson = 0;
        var decay;
        var curr_event = 0;
        const threshold = gthreshold;
        for(var i = 0; i < sel_data.length; i++){
            if(sel_data[i].maccl > threshold){
                sel_data[i].active = 1;
                decay = lookforward; //whenever other threshold, reset decay counter to the top value.
                //sel_data[i].decay = decay;
                if(syson == 0){ 
                    //CONDITION: if accel is over threshold and system was idle, go active and also look backward and set active
                    //to reduce overlap, start at the neighboring line just before: if that one is active, halt the lookback.
                    curr_event++;
                    for(var back = i - 1; back >= i - lookforward; back--){
                        if(back > 0){
                            if(sel_data[back].active > 0){
                                //abort the lookback, this is a previous event
                                back = -1; //will break the for loop
                            }
                            else{
                                sel_data[back].active = 1;
                                sel_data[back].eventcounter = curr_event;
                            }
                        }
                    }
                    syson = 1; //now set to syson to avoid any more lookbacks.
                }
                sel_data[i].eventcounter = curr_event;
            }
            else{
                if(syson > 0){
                    //CONDITION: if accel is under threshold and system was active, do the decay and check if decay hits zero
                    decay--;
                    sel_data[i].active = 1;
                    sel_data[i].eventcounter = curr_event;
                    //sel_data[i].decay = decay;
                    if(decay < 1){
                        syson = 0;
                    }
                }
                //else CONDITION: if accel is under threshold and system is off, keep data inactive.
            }
        }
        //store it in big_data
        for(var i = 0; i < sel_data.length; i++){
            if(sel_data[i].active == 1 || ignorethreshold){
                var activeitem = {};
                activeitem = sel_data[i];
                activeitem.identifier = activeitem.filename + "-" + activeitem.eventcounter.toString();
                big_data.push(activeitem);
            }
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // READYIZE
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //does basic analysis of big_data, finding unique filenames and where the cut-offs are for each event.
    function readyize(){
        //step 1: figure out the unique file names from the json and the events from each file
        filenames = []; //reset if old
        fileeventlist = []; //reset if old
        var currmax = 0;
        var prevfilename = big_data[0].filename;
        var thisfilename;
        var currsum = 0;
        for(var line = 0; line < big_data.length; line++){
            thisfilename = big_data[line].filename;
            if(prevfilename != thisfilename){
                filenames.push(prevfilename);
                prevfilename = thisfilename;
                fileeventlist.push(currmax);
                currsum += currmax; //currsum will store total number of events in this big_data.
                currmax = 0; //if a new file is reached, except on line 0, store the current max event counter for that filename
                // and then reset it to 0 for analyzing the next file
            }
            if(big_data[line].eventcounter > currmax){
                currmax = big_data[line].eventcounter; 
                //rely on structure that event counters reset back to 1 with each new file, so dont need special code at beginning
                //because the first eventcounter will be a 1 and currmax starts at 0
                //when eventcounter goes back to 1, the filename will also incremement, so the filename checks handles the rest
            }
        }
        fileeventlist.push(currmax); //last line isn't a new file, but still need to store tail end of event counters
        filenames.push(thisfilename);
        currsum += currmax;
        document.getElementById("datastatus").innerHTML = "there are "+filenames.length+" filenames and "+big_data.length+" lines in my data.";
        
        //prog bar will be 100/#events for each #event
        var stepsize = 100/currsum;

        //step 2: turn all of the big_data chunks into little chunks for drawing using the filter function
        organized_data = new Array(filenames.length);
        for(var f = 0; f < filenames.length; f++){
            var foption = document.createElement('option');
            foption.text = foption.value = filenames[f];
            document.getElementById("idselectfile").add(foption);
            organized_data[f] = new Array(fileeventlist[f]+1);
            var subfiledata = big_data.filter(function(d){ return d.filename == filenames[f]});
            organized_data[f][0] = subfiledata;
            for(var event_id = 1; event_id <= fileeventlist[f]; event_id++){
                var subsetdata = subfiledata.filter(function(d){ return d.eventcounter == event_id});
                organized_data[f][event_id] = subsetdata; //I hope this works.                
            }
        }
        document.getElementById("datastatus").innerHTML = " Data contains "+filenames.length+" logs, "+currsum+" total events.";
        document.getElementById("id_draw_button").disabled = false;
        document.getElementById("id_draw_next").disabled = false;
        newselectfile();
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // MATCH EVENTS
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function getTimeDiff(t1, t2){ //year, month, day, hours (24), minutes (60)
        //returns true/false if inside the programmed threshold of 10 minutes. doesn't compute difference itself.
        //take difference of time, then absolute value, then see if less than 10.
        var timediff = {};
        var time1 = {};
        var time2 = {};
        time1.year = t1.year;
        time1.month = t1.month;
        time1.day = t1.day;
        time1.hour = t1.hour;
        time1.minute = t1.minute;
        time2.year = t2.year;
        time2.month = t2.month;
        time2.day = t2.day;
        time2.hour = t2.hour;
        time2.minute = t2.minute;
        timediff.minute = time1.minute - time2.minute; //34 - 40 --> add 60 to (borrow one)
        if(timediff.minute < 0){
            timediff.minute += 60;
            time1.hour -= 1;
        }
        timediff.hour = time1.hour - time2.hour;
        if(timediff.hour < 0){
            timediff.hour += 24;
            time1.day -= 1;
        }
        timediff.day = time1.day - time2.day;
        if(timediff.day < 0){
            timediff.day += 31; //fixed for january :P !!
            time1.month -= 1; 
        }
        timediff.month = time1.month - time2.month;
        if(timediff.month < 0){
            return false;
        }
        return (timediff.month == 0 && timediff.day == 0 && timediff.hour == 0 && timediff.minute < 3);
    }
    function matchevents(){
        //known_event_data is filled from the open event xlsx, with headings:
        // year XXXX, month XX, day XX, hour ZZ, minute ZZ, weight XXXX, height L/M/H, config A/L
        // only need to use the month/day/time to make matches, and provide a 1-1 match of the biggest event within 3 minutes
        // of the known event time.
        //organized data has structure of events start at index 1, and index 0 is the "all data" event
        //console.log(known_event_data);
        var filehits= new Array(50);
        var eventhits= new Array(50);
        for(var iknown = 0; iknown < known_event_data.length; iknown++){
            //var best_match_file = -1;
            //var best_match_event = -1;
            var time2 = {};
            time2.year = parseIntNaN(known_event_data[iknown].year);
            time2.month = parseIntNaN(known_event_data[iknown].month);
            time2.day = parseIntNaN(known_event_data[iknown].day);
            time2.hour = parseIntNaN(known_event_data[iknown].hour);
            time2.minute = parseIntNaN(known_event_data[iknown].minute);
            var esensor = parseIntNaN(known_event_data[iknown].sensor);
            //console.log(iknown,time2);
            var maxg = 0;
            var time1 = {};
            time1.month = 0;
            time1.year = 0;
            time1.day = 0;
            time1.hour = 0;
            time1.minute = 0;
            var csensor = 0;
            for(var ifile = 0; ifile < organized_data.length; ifile++){
                for(var ievent = 1; ievent < organized_data[ifile].length; ievent++){
                    //see if time is close first, use time at middle of event:
                    var eventmiddle = Math.floor(organized_data[ifile][ievent].length/2);
                    if(eventmiddle > 10){ //only if there is at least 20 samples in this event
                        csensor = parseIntNaN(organized_data[ifile][ievent][eventmiddle].filename.slice(3,7));
                        var fname = organized_data[ifile][ievent][eventmiddle].filename;
                        time1.year = parseIntNaN(organized_data[ifile][ievent][eventmiddle].GPSDateTime.slice(0,4));
                        time1.month = parseIntNaN(organized_data[ifile][ievent][eventmiddle].GPSDateTime.slice(4,6));
                        time1.day = parseIntNaN(organized_data[ifile][ievent][eventmiddle].GPSDateTime.slice(6,8));
                        time1.hour = parseIntNaN(organized_data[ifile][ievent][eventmiddle].GPSDateTime.slice(9,11));
                        time1.minute = parseIntNaN(organized_data[ifile][ievent][eventmiddle].GPSDateTime.slice(11,13));
                        if(csensor == esensor){
                            if(getTimeDiff(time1,time2) || getTimeDiff(time2,time1)){
                                var used = false;
                                var datetime = "";
                                for(var isample = 0; isample < organized_data[ifile][ievent].length; isample++){
                                    var thisg = organized_data[ifile][ievent][isample].maccl;
                                    if(thisg > maxg){
                                        maxg = thisg;
                                        used = true;
                                        datetime = organized_data[ifile][ievent][isample].GPSDateTime;
                                    }
                                }
                                if(used){
                                    known_event_data[iknown].maxg = maxg;
                                    known_event_data[iknown].csensor = csensor;
                                    known_event_data[iknown].filename = fname;
                                    known_event_data[iknown].event_num = ievent;
                                    known_event_data[iknown].identifier = fname+"-"+ievent.toString();
                                    known_event_data[iknown].GPSDateTime = datetime;
                                    //if(csensor != esensor){
                                    //    known_event_data[iknown].sensormatch = "false";
                                    //}
                                    //else{
                                    //    known_event_data[iknown].sensormatch = "";
                                    //}
                                }
                            }
                        }
                    } 
                }
            }
            if(maxg < 1){
                known_event_data[iknown].maxg = "NA";
                known_event_data[iknown].csensor = "NA";
                known_event_data[iknown].filename = "NA";
                known_event_data[iknown].event_num = "NA";
                known_event_data[iknown].GPSDateTime = "NA";
                //known_event_data[iknown].sensormatch = "";
            }
        }
        downloadMatchesXLSX();
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // DRAW SELECTED
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function lower(a,b){
        if (a < b) return a;
        return b;
    }
    var alreadyplotted = false;
    function drawSelected(){
        if(alreadyplotted){
            d3.select("svg").remove(); 
        }
        alreadyplotted = true;
        //form org'd data, push into plottable x-y pairs only the range of interest 
        //to do: code out range of interest on the x-axis in terms of the event sample number
        var whicheventselected = parseInt(document.getElementById("idselectevent").value);
        var plottable_data = [];
        var xmin = parseInt(document.getElementById("idxmin").value);
        var xmax = document.getElementById("idxmax").value;
        var ymin = document.getElementById("idymin").value;
        var ymax = document.getElementById("idymax").value;
        var draw_opts = [   document.getElementById("idmaccl").checked,
                            document.getElementById("idxaccl").checked,
                            document.getElementById("idyaccl").checked,
                            document.getElementById("idzaccl").checked];
        var tzero = -1;
        var tfini = -1;
        var dotradius = parseInt(document.getElementById("idradius").value);
        var xsize = organized_data[whichfileselected][whicheventselected].length;
        if(xmax > xsize){
            xmax = xsize;
            document.getElementById("idxmax").value = xsize;
        }
        if (xmin < 0){
            xmin = 0;
            document.getElementById("idxmin").value = 0;
        }
        var howmanytoplot = 0;
        var theselabels = [];
        for(var param = 0; param < thelabels.length; param++){
            if(draw_opts[param]){
                howmanytoplot++;
                theselabels.push(thelabels[param]);                
                var entrypair = {};
                    entrypair.name = thelabels[param];
                    entrypair.values = [];
                for(var i = xmin; i < xmax; i++){
                    var xypair = {};
                    xypair.time = organized_data[whichfileselected][whicheventselected][i].time/1000;
                    xypair.value = organized_data[whichfileselected][whicheventselected][i][thelabels[param]];
                    entrypair.values.push(xypair);
                }
                plottable_data.push(entrypair);
            }
        }
        var timestamp = organized_data[whichfileselected][whicheventselected][0].GPSDateTime;
        tzero = organized_data[whichfileselected][whicheventselected][xmin].time/1000;
        tfini = organized_data[whichfileselected][whicheventselected][xmax-2].time/1000; //edges are sometimes corrupt. use 1-away to mark axis
        //now draw the plot given plottable_data

        var margin = {top: 10, right: 100, bottom: 30, left: 30},
            width = 1700 - margin.left - margin.right,
            height = 700 - margin.top - margin.bottom;
        var svg = d3.select("#theplot").append("svg").attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom).append("g")
                    .attr("transform","translate(" + margin.left + "," + margin.top + ")");
        var myColor = d3.scaleOrdinal().domain(theselabels).range(d3.schemeSet1);
        var x = d3.scaleLinear().domain([tzero,tfini]).range([ 0, width ]);
        svg.append("g").attr("transform", "translate(0," + height + ")").call(d3.axisBottom(x));
        var y = d3.scaleLinear().domain([ymin,ymax]).range([ height, 0 ]);
        svg.append("g").call(d3.axisLeft(y));
        var line = d3.line().x(function(d) { return x(+d.time) }).y(function(d) { return y(+d.value) })
        svg.selectAll("myLines").data(plottable_data).enter().append("path").attr("d", function(d){ return line(d.values) } )
            .attr("stroke", function(d){ return myColor(d.name) }).style("stroke-width", 1).style("fill", "none");
        svg.selectAll("myDots").data(plottable_data).enter().append('g').style("fill", function(d){ return myColor(d.name) })
            .selectAll("myPoints").data(function(d){ return d.values }).enter().append("circle")
            .attr("cx", function(d) { return x(d.time) } )
            .attr("cy", function(d) { return y(d.value) } ).attr("r", dotradius)
            .append("svg:title").text(function(d){ return ("t:"+d.time.toString()+", "+d.value.toString())});
            //.attr("stroke", "white")
        //LEGEND
        svg.append('g').append("text").attr("x",12).attr("y",10).text("File: "+filenames[whichfileselected]).style("fill","black").style("font-size",18);
        svg.append('g').append("text").attr("x",12).attr("y",30).text("Event: "+whicheventselected).style("fill","black").style("font-size",18);
        svg.append('g').append("text").attr("x",12).attr("y",50).text("GPS Time: "+timestamp).style("fill","black").style("font-size",18);
        for(var q = 0; q < howmanytoplot; q++){
            var maxval = getabsmax(plottable_data[q].values);
            svg.append('g').append("text").attr("x",12).attr("y",70+20*q).text(theselabels[q]+", max(absolute): "+maxval)
            .style("fill",thecolors[q]).style("font-size",18);
        }
        //internal function that gets the absolute maximum of G from Y in an X-Y pair array that is svg-ready (array of .value)
        function getabsmax(valuearray){
            var absmax = 0;
            var absmin = 0;
            for(let a = 0; a < valuearray.length; a++){
                if(valuearray[a].value > absmax){
                    absmax = valuearray[a].value;
                }
                if(valuearray[a].value < absmin){
                    absmin = valuearray[a].value;
                }
            }
            if(-absmin > absmax){
                return -absmin;
            }
            return absmax;
        }
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // DEPRECATED PLOT ALL FUNCTION
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function plotAll(jsonny){
        
        var margin = {top: 10, right: 100, bottom: 30, left: 30},
            width = 1700 - margin.left - margin.right,
            height = 700 - margin.top - margin.bottom;
       
        //put data into the weird key'd x,y pairings
        
        for(var f = 0; f < filenames.length; f++){
            var subfiledata = big_data.filter(function(d){ return d.filename == filenames[f]});
            if(ploteverthing){
                var tstart = document.getElementById("idxmin").value;
                var tfinish = document.getElementById("idxmax").value;
                var subfiledata = jsonny.slice(tstart, tfinish);
                readyizeanddraw(subfiledata, 0);
            }
            else{
                for(var event_id = 1; event_id <= fileeventlist[f]; event_id++){
                    var subsetdata = subfiledata.filter(function(d){ return d.eventcounter == event_id});
                    readyizeanddraw(subsetdata, event_id);
                }
            }
            function readyizeanddraw(subsetdata,event_id){
                var readydata = [];
                var timestamp = subsetdata[0].GPSDateTime;
                var xmax = subsetdata.length;
                function readywhich(which){
                    var readyentry = {};
                    readyentry.name = which;
                    readyentry.values = [];
                    for(var t = 0; t < subsetdata.length; t++){
                        var xypair = {};
                        xypair.time = t;
                        xypair.value = subsetdata[t][which];
                        readyentry.values.push(xypair);
                    }
                    readydata.push(readyentry);
                }
                readywhich("maccl");
                readywhich("xaccl");
                readywhich("yaccl");
                readywhich("zaccl");
                var svg = d3.select("#my_dataviz").append("svg").attr("width", width + margin.left + margin.right)
                            .attr("height", height + margin.top + margin.bottom).append("g")
                            .attr("transform","translate(" + margin.left + "," + margin.top + ")");
                var myColor = d3.scaleOrdinal().domain(thelabels).range(d3.schemeSet1);
                var x = d3.scaleLinear().domain([0,xmax]).range([ 0, width ]);
                svg.append("g").attr("transform", "translate(0," + height + ")").call(d3.axisBottom(x));
                var y = d3.scaleLinear().domain([-25,25]).range([ height, 0 ]);
                svg.append("g").call(d3.axisLeft(y));
                var line = d3.line().x(function(d) { return x(+d.time) }).y(function(d) { return y(+d.value) })
                svg.selectAll("myLines").data(readydata).enter().append("path").attr("d", function(d){ return line(d.values) } )
                    .attr("stroke", function(d){ return myColor(d.name) }).style("stroke-width", 1).style("fill", "none");
                svg.selectAll("myDots").data(readydata).enter().append('g').style("fill", function(d){ return myColor(d.name) })
                    .selectAll("myPoints").data(function(d){ return d.values }).enter().append("circle")
                    .attr("cx", function(d) { return x(d.time) } )
                    .attr("cy", function(d) { return y(d.value) } ).attr("r", 2)
                    //.attr("stroke", "white")
                //LEGEND
                svg.append('g').append("text").attr("x",12).attr("y",10).text("File: "+filenames[f]).style("fill","black").style("font-size",18);
                svg.append('g').append("text").attr("x",12).attr("y",30).text("Event: "+event_id).style("fill","black").style("font-size",18);
                svg.append('g').append("text").attr("x",12).attr("y",50).text("GPS Time: "+timestamp).style("fill","black").style("font-size",18);
                for(var q = 0; q < 4; q++){
                    var maxval = getabsmax(readydata[q].values);
                    svg.append('g').append("text").attr("x",12).attr("y",70+20*q).text(thelabels[q]+", max(absolute): "+maxval)
                       .style("fill",thecolors[q]).style("font-size",18);
                }
            }
        }
        //internal function that gets the absolute maximum of G from Y in an X-Y pair array that is svg-ready (array of .value)
        function getabsmax(valuearray){
            var absmax = 0;
            var absmin = 0;
            for(let a = 0; a < valuearray.length; a++){
                if(valuearray[a].value > absmax){
                    absmax = valuearray[a].value;
                }
                if(valuearray[a].value < absmin){
                    absmin = valuearray[a].value;
                }
            }
            if(-absmin > absmax){
                return -absmin;
            }
            return absmax;
        }
        drewonce = true;
    }

</script>
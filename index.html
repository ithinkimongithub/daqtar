<!DOCTYPE html>
<html>
<script lang="javascript" src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script> <!--Sheets JS-->
<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Color Scale -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<head>
<title>Page Title</title>
</head>
<body>
<p>Step 1. Use Batch Rename Utility to put "serXXXX" where XXXX is the sensor serial number at the front of the file name for each LOG file</p>
<p>Step 2. Place all LOG files in a single directory with the logdecoder.exe. In this example, this was "C:\idaq\space\"</p>
<p>Step 3. Make a new Batch file (that's text with extension .bat) in this directory with the only line inside: "for %%f in (.\ser*) DO c:\idaq\space\logdecoder.exe %%f"</p>
<p>Step 4. Execute the Batch file. This should open a terminal and show the logdecoder.exe at work</p>
<p>Step 5. Modify parameters as you see fit. The G-threshold is the magnitude of the acceleration vector, and framesize
    is how many samples to capture on either side of an event that is over that G-threshold.</p>
<label for="gthreshold">G threshold:</label>
<input type="number" id="idgthreshold" name="gthreshold" value="3" step="0.1">Decimals allowed<br><br>
<label for="framesize">Look back/look forward:</label>
<input type="number" id="idframesize" name="framesize" value="1000" step="1">Whole numbers only<br><br>
<label for="gimme">Ignore thresholds, I want everything!</label>
<input type="checkbox" id="idgimme" name="gimme" onchange="goignorecheckbox()">You may run out of memory!<br><br>
<label for="gimmemore">Just skip the save/open, take me straight to the chart:</label>
<input type="checkbox" id="idgimmemore" name="gimmemore" onchange="gochartcheckbox()">Nice shortcut!<br><br>
<p>Step 6. Use the "Open" button to select all files of interest. Your browswer will prompt you to save the output file. It's a .xlsx and I hope it fits on your computer!</p>
<p>CSV File(s): <input multiple type="file" name="fileinput" id="fileinputid" onchange="openBatchCSV()" accept=".csv"/></p>
<p>Step 7. Load that excel back to me, and I will then plot out every shock as a function of time, independently, for you to look at, with Z-axis flipped so that impact is positive</p>
<p>XLSX File: <input type="file" name="xlsxinput" id="xlsxinputid" onchange="openOneXLSX()" accept=".xlsx"/></p>
<p id="rstatus">status:</p>
<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>
</body>
<script>

    var curr_file;
    var num_files;
    var big_data = [];
    var linecount;
    var framesize;
    var gthreshold;
    var ignorethreshold = false;
    var straighttochart = false;

    function openOneXLSX(){
        var f = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e){
            var binaryString = e.target.result;
            var inputWorkbook = XLSX.read(binaryString, {type: 'binary'});
            var firstSheetname = inputWorkbook.SheetNames[0];
            var firstWorksheet = inputWorkbook.Sheets[firstSheetname];
            var firstJSON = XLSX.utils.sheet_to_json(firstWorksheet, {defval:"0"});
            plotAll(firstJSON);
        }
        reader.readAsBinaryString(f);
    }

    function plotAll(jsonny){
        //step 1: figure out the unique file names from the excel file
        var filenames = [];
        var fileeventlist = [];
        var currmax = 0;
        for(var line = 0; line < jsonny.length; line++){
            if(jsonny[line].eventcounter > currmax){
                currmax = jsonny[line].eventcounter; //rely on structure that event counters reset back to 1 with each new file, so dont need special code at beginning
            }
            var thisfilename = jsonny[line].filename;
            if(!filenames.includes(thisfilename)){
                filenames.push(thisfilename);
                if(line > 0){
                    fileeventlist.push(currmax);
                    currmax = 0; //if a new file is reached, except on line 0, store the current max event counter and reset it to 0.
                }
            }
        }
        fileeventlist.push(currmax); //last line isn't a new file, but still need to store tail and of event counters
        console.log(filenames, fileeventlist);

        document.getElementById("rstatus").innerHTML += "there are "+filenames.length+" unique file names in this file:";
        var margin = {top: 10, right: 100, bottom: 30, left: 30},
            width = 1700 - margin.left - margin.right,
            height = 700 - margin.top - margin.bottom;
        // append the svg object to the body of the page
       
        //put data into the weird key'd x,y pairings
        const thelabels = ["maccl","xaccl","yaccl","zaccl"];
        const thecolors = d3.schemeSet2;
        console.log(thecolors);
        for(var f = 0; f < filenames.length; f++){
            var subfiledata = jsonny.filter(function(d){ return d.filename == filenames[f]});
            for(var e = 1; e <= fileeventlist[f]; e++){
                var readydata = [];
                var subsetdata = subfiledata.filter(function(d){ return d.eventcounter == e});
                var timestamp = subsetdata[0].GPSDateTime;
                var xmax = subsetdata.length;
                function readywhich(which){
                    var readyentry = {};
                    readyentry.name = which;
                    readyentry.values = [];
                    for(var t = 0; t < subsetdata.length; t++){
                        var xypair = {};
                        xypair.time = t;
                        xypair.value = subsetdata[t][which];
                        readyentry.values.push(xypair);
                    }
                    readydata.push(readyentry);
                }
                readywhich("maccl");
                readywhich("xaccl");
                readywhich("yaccl");
                readywhich("zaccl");
                console.log(readydata);
                var svg = d3.select("#my_dataviz").append("svg").attr("width", width + margin.left + margin.right)
                             .attr("height", height + margin.top + margin.bottom).append("g")
                             .attr("transform","translate(" + margin.left + "," + margin.top + ")");
                // A color scale: one color for each group
                var myColor = d3.scaleOrdinal().domain(filenames).range(d3.schemeSet2);
                // Add X axis --> it is a date format
                var x = d3.scaleLinear().domain([0,xmax]).range([ 0, width ]);
                svg.append("g").attr("transform", "translate(0," + height + ")").call(d3.axisBottom(x));
                // Add Y axis
                var y = d3.scaleLinear().domain([-25,25]).range([ height, 0 ]);
                svg.append("g").call(d3.axisLeft(y));
                // Add the lines
                var line = d3.line().x(function(d) { return x(+d.time) }).y(function(d) { return y(+d.value) })
                svg.selectAll("myLines").data(readydata).enter().append("path").attr("d", function(d){ return line(d.values) } )
                    .attr("stroke", function(d){ return myColor(d.name) }).style("stroke-width", 1).style("fill", "none");
                // Add the points
                svg.selectAll("myDots").data(readydata).enter().append('g').style("fill", function(d){ return myColor(d.name) })
                    // Second we need to enter in the 'values' part of this group
                    .selectAll("myPoints").data(function(d){ return d.values }).enter().append("circle")
                    .attr("cx", function(d) { return x(d.time) } )
                    .attr("cy", function(d) { return y(d.value) } ).attr("r", 2)
                    //.attr("stroke", "white")
                // Add a legend at the upper left corner
                svg.append('g').append("text").attr("x",12).attr("y",10).text("File: "+filenames[f]).style("fill","black").style("font-size",18);
                svg.append('g').append("text").attr("x",12).attr("y",30).text("Event: "+e).style("fill","black").style("font-size",18);
                svg.append('g').append("text").attr("x",12).attr("y",50).text("GPS Time: "+timestamp).style("fill","black").style("font-size",18);
                for(var q = 0; q < 4; q++){
                    var maxval = getabsmax(readydata[q].values);
                    svg.append('g').append("text").attr("x",12).attr("y",70+20*q).text(thelabels[q]+", |max|: "+maxval).style("fill",thecolors[q+1]).style("font-size",18);
                }
                //svg.selectAll("myLabels").data(readydata).enter().append('g').append("text")
                //    .datum(function(d) { return {name: d.name, value: d.values[0]}; }) // use x-value of start as datum
                //    ///.attr("transform", function(d) { return "translate(" + x(d.value.time) + "," + y(d.value.value) + ")"; }) // Put the text at the position of the last point
                //    .attr("transform", function(d,i){ return "translate(" + x(0) + y(5+i*10) + ")"})
                //    .attr("x", 12) // shift the text a bit more right
                //    .text(function(d) { return d.name; }).style("fill", function(d){ return myColor(d.name) }).style("font-size", 25);
            }
        }
        function getabsmax(valuearray){
            var absmax = 0;
            var absmin = 0;
            for(let a = 0; a < valuearray.length; a++){
                if(valuearray[a].value > absmax){
                    absmax = valuearray[a].value;
                }
                if(valuearray[a].value < absmin){
                    absmin = valuearray[a].value;
                }
            }
            if(-absmin > absmax){
                return -absmin;
            }
            return absmax;
        }
        /*
        //step 2: for each file name, we'll create a time vs. acceleration magnitude chart
        //for(var f = 0; f < filenames.length; f++){
        
        var time0 = subsetdata[0].time;
        var time1 = subsetdata[subsetdata.length-1].time;
        //TODO: instead of per file, reduce to per event. trigger a new event when the time-step is greater than 5 second between two lines in the file.
        var ymin  = 0;
        var ymax  = d3.max(subsetdata, d => d.maccl);
        var length = subsetdata.length;
        var svg = getNode("svg");
        document.body.appendChild(svg);
        svg.appendChild( getNode('rect', { width:200, height:20, fill:'#ff0000' }) );
        var edge = 100;
        var margin = edge*2;
        //var width = svg.attr("width") - margin;
        //var height = svg.attr("height") - margin;
        console.log(filenames[f],time0,time1,ymin,ymax);

        
        // Reformat the data: we need an array of arrays of {x, y} tuples
        var dataReady = allGroup.map( function(grpName) { // .map allows to do something for each element of the list
            return {
                name: grpName,
                values: data.map(function(d) {
                    return {time: d.time, value: +d[grpName]};
                })
            };
        });*/
    }

    function goignorecheckbox(){
        ignorethreshold = !ignorethreshold;
    }
    function gochartcheckbox(){
        straighttochart = !straighttochart;
    }

    function openBatchCSV(){
        linecount = 0;
        gthreshold = document.getElementById("idgthreshold").value;
        framesize = document.getElementById("idframesize").value;
		document.getElementById("rstatus").innerHTML += "opencsv() start,";
        var str = "20240123-204239";
        document.getElementById("rstatus").innerHTML += "*"+(str.slice(0,8))+"*";
        document.getElementById("rstatus").innerHTML += "*"+(str.slice(9))+"*";
		num_files = event.target.files.length;
		//curr_file = 0;
        //for(var i = 0; i < num_files; i++){ //commented out means this is recursive
            openOneCSV(0,event); 
        //}
		document.getElementById("rstatus").innerHTML += "opencsv() done,";
    }

    function openOneCSV(index, event){
		document.getElementById("rstatus").innerHTML += "openOnecsv() start,";
        var f = event.target.files[index];
        const reader = new FileReader();
        reader.onload = function(e){
            document.getElementById("rstatus").innerHTML += "fileReaderStarting,";
            const text = e.target.result;
            const data = d3.csvParse(text);
            var fname = f.name;
            process_json(data, fname);
            //if(curr_file == num_files - 1){
            if(index == num_files - 1){
            //draw the stuff now:
                document.getElementById("rstatus").innerHTML += "Last file completed. pulled "+big_data.length+" lines from "+linecount+" total lines";
                //generateTable(big_data,1000);
                if(straighttochart){
                    plotAll(big_data);
                }
                else{
                    downloadXLSX(big_data);
                }
            }
            else{
                openOneCSV(index+1, event);
            }
            curr_file++;
        };
        reader.readAsText(f);
    }

    function process_json(data, filename){
        var sel_data = data.map(
            ({
                time, xgyro, ygyro, zgyro, xaccl, yaccl, zaccl, GPSFixMode, GPSDateTime, 
                //GPSLongitude, GPSLatitude, 
                GPSGroundSpeed
            }) =>
            {
            return{
                time, xgyro, ygyro, zgyro, xaccl, yaccl, zaccl, GPSFixMode, GPSDateTime, 
                //GPSLongitude, GPSLatitude, 
                GPSGroundSpeed
                }
            }
        );
        for(var i = 0; i < sel_data.length; i++){
            //add metadata
            function parseFloatNaN(passed){
                var answer = parseFloat(passed);
                if(isNaN(answer)) return 0;
                return answer;
            }
            function parseIntNan(passed){
                var answer = parseInt(passed);
                if(isNaN(answer)) return 0;
                return answer;
            }
            sel_data[i].filename = filename;
            sel_data[i].line = linecount;
            linecount++;
            sel_data[i].decay = 0;
            sel_data[i].eventcounter = 0;
			//make sure all text is entered as float/int values
			sel_data[i].time = parseInt(sel_data[i].time);
			sel_data[i].xgyro = parseFloatNaN(sel_data[i].xgyro);
            sel_data[i].ygyro = parseFloatNaN(sel_data[i].ygyro);
            sel_data[i].zgyro = parseFloatNaN(sel_data[i].zgyro);
            sel_data[i].xaccl = parseFloatNaN(sel_data[i].xaccl);
            sel_data[i].yaccl = parseFloatNaN(sel_data[i].yaccl);
            sel_data[i].zaccl = parseFloatNaN(sel_data[i].zaccl);
            sel_data[i].maccl = Math.sqrt(sel_data[i].xaccl*sel_data[i].xaccl+sel_data[i].yaccl*sel_data[i].yaccl+sel_data[i].zaccl*sel_data[i].zaccl);
            sel_data[i].active = 0;
            sel_data[i].GPSFixMode = parseInt(sel_data[i].GPSFixMode);
            //GPSDateTime will remain as text excample 20240123-204239
            sel_data[i].GPSDate = parseIntNan(sel_data[i].GPSDateTime.slice(0,8));
            sel_data[i].GPSTime = parseIntNan(sel_data[i].GPSDateTime.slice(9));
            //sel_data[i].GPSLongitude = parseFloat(sel_data[i].GPSLongitude);
            //sel_data[i].GPSLatitude = parseFloat(sel_data[i].GPSLatitude);
            sel_data[i].GPSGroundSpeed = parseFloatNaN(sel_data[i].GPSGroundSpeed);
        }
        //threshold finder
        const lookforward = framesize;
        var syson = 0;
        var decay;
        var curr_event = 0;
        const threshold = gthreshold;
        for(var i = 0; i < sel_data.length; i++){
            if(sel_data[i].maccl > threshold){
                sel_data[i].active = 1;
                decay = lookforward; //whenever other threshold, reset decay counter to the top value.
                sel_data[i].decay = decay;
                if(syson == 0){ 
                    //CONDITION: if accel is over threshold and system was idle, go active and also look backward and set active
                    curr_event++;
                    for(var back = i - lookforward; back < i; back++){
                        if(back > 0){
                            sel_data[back].active = 1;
                            sel_data[back].eventcounter = curr_event;
                        }
                    }
                    syson = 1; //now set to syson to avoid any more lookbacks.
                }
                sel_data[i].eventcounter = curr_event;
            }
            else{
                if(syson > 0){
                    //CONDITION: if accel is under threshold and system was active, do the decay and check if decay hits zero
                    decay--;
                    sel_data[i].active = 1;
                    sel_data[i].eventcounter = curr_event;
                    sel_data[i].decay = decay;
                    if(decay < 1){
                        syson = 0;
                    }
                }
                //else CONDITION: if accel is under threshold and system is off, keep data inactive.
            }
        }
        //store it
        //var filtered = [];
        for(var i = 0; i < sel_data.length; i++){
            //linecount++;
            if(sel_data[i].active == 1 || ignorethreshold){
                var activeitem = {};
                activeitem = sel_data[i];
                //filtered.push(activeitem);
                big_data.push(activeitem);
            }
            if(i == sel_data.length -1){
                document.getElementById("rstatus").innerHTML += "File Time (ms): "+sel_data[i].time;
            }
        }
        //generateTable(sel_data, 2);
        //big_data.push(filtered);
    }

    function generateTable(data, maxlines) {
        // creates a <table> element and a <tbody> element
        const tbl = document.createElement("table");
        const tblBody = document.createElement("tbody");
        if(data.length < 1){
            console.log("array of length 0");
        }
        // creating all cells
        for (let i = 0;  i < data.length && i < maxlines; i++) {
            // creates a table row
            const row = document.createElement("tr");

            for (let key in data[i]) {
                // Create a <td> element and a text node, make the text
                // node the contents of the <td>, and put the <td> at
                // the end of the table row
                const cell = document.createElement("td");
                const cellText = document.createTextNode(data[i][key].toString());
                cell.appendChild(cellText);
                row.appendChild(cell);
            }
            // add the row to the end of the table body
            tblBody.appendChild(row);
        }
        // put the <tbody> in the <table>
        tbl.appendChild(tblBody);
        // appends <table> into <body>
        document.body.appendChild(tbl);
        // sets the border attribute of tbl to '2'
        tbl.setAttribute("border", "2");
    }


    function downloadXLSX(data) {
        const worksheet = XLSX.utils.json_to_sheet(data);		
	    const workbook  = XLSX.utils.book_new();
	    XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
	    XLSX.writeFile(workbook, "output.xlsx", {compression:true});
    }
</script>